<div id="container">

    <!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="/css/stylesheet.css">
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" rel="stylesheet">

        <title>`this` in Javascript</title>

    </head>
    <body>
        <header id="page-title">
            <h1><a href="/">[Sergey Moraru]</a></h1>
        </header>



    <article id="content">
        <header>
            <h1>`this` in Javascript</h1>
            <p class="blog-post-subheader">
                Published on  September 2, 2019
            </p>
        </header>
        <div class="blog-post-content">
            

<p>Scope in Javascript is a set of rules that determines how and where a variable(identifier) can be looked up.</p>

<h3 id="a-brief-refresher">A brief refresher.</h3>

<p>To understand scope, you need to be familiar with some basics of how Javascript (or any other programming language, really) works. Unlike other languages out there, Javascript code is compiled right before (like &lt; 1ms) execution, which is crazy fast. The main parts of this process are:
1. <em>Engine</em> - responsible for compilation and execution of the program
2. <em>Compiler</em> - handles the tokenization, parsing (takes an array of tokens, eg <code>var</code>,<code>x</code>,<code>=</code>,<code>1</code>,<code>;</code> and turns it in a tree of nested elements) and code-generation — the process of taking the tree and turning it into executable code.
3. <em>Scope</em> - collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.</p>

<p>Let’s break down the following expression:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4">var x = 1;</pre></div>
<p>First thing that occurs is Compiler declares <code>var x;</code> in the current scope (if it previously wasn’t declared in the current scope) and second - the Engine looks up the variable in the scope and assigns a value if found(<code>= 1;</code>).  This is a /LHS look up/.
    Look-ups may be for the purpose of assigning a value to the variable which is <em>LHS (left-hand-side) reference</em> (eg  <code>var x = 1;</code>) , or may for the purposes of retrieving a value - which is a <em>RHS(right-hand-side) reference</em> (eg  <code>console.log(x)</code>). LHS references result from assignment operation. Scope related assignments can occur either with the <code>=</code> operator or when passing arguments to functions parameters.</p>

<h3 id="nested-scope">Nested scope.</h3>

<p>Usually there is more than one scope to consider. Just as a function block can be nested in another, so can scopes be nested in other scopes. In that case, if a variable cannot be found in the immediate scope, the engine consults the next outer containing scope, continuing until found or until the outermost (eg global) scope has been reached. If not found - it throws a <code>ReferenceError</code> - meaning that a RHS look-up failed. By contrast, if the engine does a LHS look-up (not in “strict  mode”) and doesn’t find the variable by the time it reaches the global scope - it automatically creates one(in “strict mode” it throws <code>ReferenceError</code> ). If a value is found for RHS and you try to do something with its value that is impossible (like referencing a property on <code>null</code> or <code>undefined</code> value) the engine throws a <code>TypeError</code>. <code>ReferenceError</code> is scope resolution-failure related, whereas <code>TypeError</code> implies that scope resolution was successful, but that there was an illegal/impossible action attempted against the result.</p>

<h3 id="lexical-scope">Lexical scope.</h3>

<p>As we already now, before executing, a program undergoes  compilation process. Before the compiler parses the code, it tokenizes (also know as lexing which basically  means examining a string of source code characters and assigning semantic meaning to the tokens ) our code into small chunks. The scope defined at this stage is in fact the /Lexical Scope/. — and is based on where variables and blocks of scope are authored (at write time). When nesting functions, each function has its own local scope, and the variable look-up starts at the innermost function scope and stops once it finds the first match, otherwise the look up ends in the global scope. The same identifier can be found in multiple nested scopes - called “shadowing”, when innermost found match overshadows the outer scope ones. Shadowed variables cannot be accessed except the global one, which in browser for example is a property on the <code>window</code> object.
!!! <em>No matter where a function is invoked from, or even how it is invoked, its lexical scope is only defined by where the function was declared.</em> (this gives great power we can use in our code — /Closures/ are based on this concept).</p>

<h3 id="functions-as-scope">Functions as Scope.</h3>

<p>Functions are the most common unit of scope in Javascript. Variables and functions that are declared in another functions are hidden from any surrounding scopes, which is an intentional design principle.</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#008000;font-weight:bold">var</span> x <span style="color:#666">=</span> <span style="color:#666">1</span>;

<span style="color:#008000;font-weight:bold">function</span> foo(){

    <span style="color:#008000;font-weight:bold">var</span> x <span style="color:#666">=</span> <span style="color:#666">3</span>;
    console.log( x );

};
foo(); <span style="color:#408080;font-style:italic">//3
</span><span style="color:#408080;font-style:italic"></span>console.log( x ); <span style="color:#408080;font-style:italic">// 1
</span></code></pre></div>
<p>To avoid polluting the enclosing scope (global one here specifically) by declaring the function and later when we invoke it, we can refactor the function declaration in a immediate invoked function expression (IIFE) —</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#008000;font-weight:bold">var</span> x <span style="color:#666">=</span> <span style="color:#666">1</span>;
(<span style="color:#008000;font-weight:bold">function</span> foo(){

    <span style="color:#008000;font-weight:bold">var</span> x <span style="color:#666">=</span> <span style="color:#666">3</span>;
    console.log( x ); <span style="color:#408080;font-style:italic">//3
</span><span style="color:#408080;font-style:italic"></span>
})();
console.log( x ); <span style="color:#408080;font-style:italic">// 1
</span></code></pre></div>
<p>Here, the name <code>foo</code> is not bound to enclosing (global) scope, but instead — to its own function. The braces that wraps the function declaration actually transforms it in a function expressions and adding a pair of  <code>()</code> at the end — invokes it immediately. The most common form of IIFEs is to use an anonymous function expression, but it is recommended to name them as it is easier to debug (the name appears in stack traces), can call itself when necessary(eg recursion) , and all in all makes the code more readable.
Another variation on IIFE&rsquo;s which is quite common is to use the fact that they are just function calls, and pass in argument(s). For instance:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#008000;font-weight:bold">var</span> a <span style="color:#666">=</span> <span style="color:#666">2</span>;

(<span style="color:#008000;font-weight:bold">function</span> IIFE( global ){

    <span style="color:#008000;font-weight:bold">var</span> a <span style="color:#666">=</span> <span style="color:#666">3</span>;
    console.log( a ); <span style="color:#408080;font-style:italic">// 3
</span><span style="color:#408080;font-style:italic"></span>    console.log( global.a ); <span style="color:#408080;font-style:italic">// 2
</span><span style="color:#408080;font-style:italic"></span>
})( <span style="color:#008000">window</span> );
</code></pre></div>
<h3 id="blocks-as-scopes">Blocks as Scopes.</h3>

<p>While functions are the most common unit of scope, and certainly the most wide-spread of the design approaches in the majority of JS in circulation, other units of scope are possible, and the usage of these other scope units can lead to even better, cleaner to maintain code. Javascript, unlike other  languages, doesn’t support the pure Block Scope per se. Take this example —</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#008000;font-weight:bold">for</span> (<span style="color:#008000;font-weight:bold">var</span> i<span style="color:#666">=</span><span style="color:#666">0</span>; i<span style="color:#666">&lt;</span><span style="color:#666">10</span>; i<span style="color:#666">++</span>) {
    console.log( i );
}
</code></pre></div>
<p>We would assume that we use the variable <code>i</code> explicitly in the loop context, but it actually scopes in enclosing scope (function or global). Fortunately, ES6 introduces a new keyword <code>let</code> which acts as another way to declare variables. The <code>let</code> keyword attaches the variable declaration to whatever block (<code>{}</code>) it’s contained in, it hijacks any block scope for its variable declaration.</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#008000;font-weight:bold">var</span> foo <span style="color:#666">=</span> <span style="color:#666">1</span>;

<span style="color:#008000;font-weight:bold">if</span> (foo <span style="color:#666">===</span> <span style="color:#666">1</span>) {
    <span style="color:#008000;font-weight:bold">let</span> bar <span style="color:#666">=</span> foo <span style="color:#666">*</span> <span style="color:#666">2</span>;
    console.log( bar );
};
console.log( bar ); <span style="color:#408080;font-style:italic">// ReferenceError
</span></code></pre></div>
<p>It is worth mentioning that <code>let</code> declaration are not hoisted at the top of the block they appear in, so if you use them before declaring you will get a <code>ReferenceError</code>.</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">{
   console.log( foo ); <span style="color:#408080;font-style:italic">// ReferenceError!
</span><span style="color:#408080;font-style:italic"></span>   <span style="color:#008000;font-weight:bold">let</span> foo <span style="color:#666">=</span> 	<span style="color:#666">1</span>;
}
</code></pre></div>
<p>A quick mention about block scope in context of garbage collection. We will talk about closures in another post, but in two words — a closure is a function’s ability to remember it enclosing scope even after it has run. So, the outer scope of that function is retained for this reason and is not garbage collected because it can still be used by some functions. Here comes the block scoping and it can help reclaim memory by allowing itself being garbage collected.  Consider this —</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#008000;font-weight:bold">function</span> doSomething() {
	<span style="color:#408080;font-style:italic">//it has a closure on its outer scope
</span><span style="color:#408080;font-style:italic"></span>}
<span style="color:#408080;font-style:italic">//anything declared inside this block can be garbage collected
</span><span style="color:#408080;font-style:italic"></span>{
	<span style="color:#008000;font-weight:bold">let</span> hugeDataObject <span style="color:#666">=</span> {...};
}
</code></pre></div>
<p>Another useful case for <code>let</code>  is in the usual <code>for</code> loops.</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#008000;font-weight:bold">for</span> (<span style="color:#008000;font-weight:bold">let</span> i<span style="color:#666">=</span><span style="color:#666">0</span>; i<span style="color:#666">&lt;</span><span style="color:#666">10</span>; i<span style="color:#666">++</span>) {
    console.log( i );
}

console.log( i ); <span style="color:#408080;font-style:italic">// ReferenceError
</span></code></pre></div>
<p>Not only it binds itself to the loop header but it also re-binds itself to the loop body on each iteration.
In addition to let, ES6 introduces <code>const</code>, which also creates a block-scoped variable, but whose value is fixed (constant). Any attempt to change that value at a later time results in an error.</p>

<p>References:</p>

<ul>
<li><a href="http://2ality.com/2015/02/es6-scoping.html">2ality</a></li>
</ul>

        </div>
    </article>

        </body>
</html>
</div>
