<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GitHub on Sergey Moraru</title>
    <link>https://ysrg.github.io/tags/github/</link>
    <description>Recent content in GitHub on Sergey Moraru</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 04 Sep 2019 05:42:10 +0300</lastBuildDate>
    
	<atom:link href="https://ysrg.github.io/tags/github/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Javascript Closures</title>
      <link>https://ysrg.github.io/posts/javascript-closures/</link>
      <pubDate>Wed, 04 Sep 2019 05:42:10 +0300</pubDate>
      
      <guid>https://ysrg.github.io/posts/javascript-closures/</guid>
      <description>Closures are all around in our code, we just need to recognize and leverage them. They happen as a result of writing code that relies heavily on lexical scope. A closure is a function that is able to remember and access its surrounding lexical scope even when that function is executing outside its lexical scope. Closures are a neat way of dealing with the following two realities of JavaScript:
 Scope is at the function level, not the block level Much of what you do in practice in JavaScript is asynchronous/event driven so there is a need to remember the scope of authored-time function declarations.</description>
    </item>
    
    <item>
      <title>Understanding scope in JS</title>
      <link>https://ysrg.github.io/posts/understand-scope/</link>
      <pubDate>Mon, 02 Sep 2019 05:42:10 +0300</pubDate>
      
      <guid>https://ysrg.github.io/posts/understand-scope/</guid>
      <description>Scope in Javascript is a set of rules that determines how and where a variable(identifier) can be looked up.
A brief refresher To understand scope, you need to be familiar with some basics of how Javascript (or any other programming language, really) works. Unlike other languages out there, Javascript code is compiled right before (like &amp;lt; 1ms) execution. The main parts of this process are: 1. Engine - responsible for compilation and execution of the program 2.</description>
    </item>
    
    <item>
      <title>Hoisting in Javascript</title>
      <link>https://ysrg.github.io/posts/js-hoisting/</link>
      <pubDate>Tue, 06 Aug 2019 05:42:10 +0300</pubDate>
      
      <guid>https://ysrg.github.io/posts/js-hoisting/</guid>
      <description>As you probably know, javascript code is interpreted line by line top-to-bottom &amp;hellip;most of the time. Consider this code &amp;ndash;
alert(x); const x = 1  Most people would assume one of the two: either the browser will alert &amp;lsquo;1&amp;rsquo; or we will get a ReferenceError, since we are using a variable before it is declared. The thing is none of the above is the right answer. Let&amp;rsquo;s take an aside for a minute and think about the internals of javascript.</description>
    </item>
    
    <item>
      <title>Server—side Authentication in NodeJS</title>
      <link>https://ysrg.github.io/posts/ss-auth-node/</link>
      <pubDate>Thu, 18 Jul 2019 05:42:10 +0300</pubDate>
      
      <guid>https://ysrg.github.io/posts/ss-auth-node/</guid>
      <description>Let us quickly put together a server app for our project:
~/ mkdir ss-auth &amp;amp;&amp;amp; $_ ~/ss-auth/npm init -y ~/ss-auth/ npm i -S express mongoose morgan body-parser ~/ss-auth/ touch index.js &amp;amp;&amp;amp; router.js It will look like so —
├── node_modules ├── index.js ├── package-lock.json ├── package.json └── router.js index.js -
const express = require(&amp;#39;express&amp;#39;); const http = require(&amp;#39;http&amp;#39;); const bodyParser = require(&amp;#39;body-parser&amp;#39;); const morgan = require(&amp;#39;morgan&amp;#39;); const mongoose = require(&amp;#39;mongoose&amp;#39;); const router = require(&amp;#39;.</description>
    </item>
    
  </channel>
</rss>